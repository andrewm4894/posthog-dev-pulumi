"""PostHog setup: clone, environment, migrations, Docker services, and screen session."""

from config import RepoConfig
from constants import POSTHOG_ENV_DEFAULTS


def get_clone_repos(posthog_branch: str, additional_repos: list[RepoConfig]) -> str:
    """Generate repository cloning section."""
    additional_clone_commands = ""
    for repo in additional_repos:
        additional_clone_commands += f'''
echo ">>> Cloning {repo.url} (branch: {repo.branch})"
git clone --branch {repo.branch} {repo.url} /home/ph/{repo.target_dir}
chown -R ph:ph /home/ph/{repo.target_dir}
'''

    return f'''
section_start "Clone Repositories"

# Check if branch exists remotely
if git ls-remote --heads https://github.com/posthog/posthog.git {posthog_branch} | grep -q {posthog_branch}; then
    echo "Branch '{posthog_branch}' exists, cloning directly"
    git clone --branch {posthog_branch} https://github.com/posthog/posthog.git /home/ph/posthog
else
    echo "Branch '{posthog_branch}' does not exist, cloning master and creating new branch"
    git clone https://github.com/posthog/posthog.git /home/ph/posthog
    cd /home/ph/posthog
    git checkout -b {posthog_branch}
    cd /
fi

chown -R ph:ph /home/ph/posthog

{additional_clone_commands}
section_end "Clone Repositories"
'''


def get_posthog_env(enable_minimal_mode: bool) -> str:
    """Generate PostHog environment setup section."""
    env_lines = "\n".join(f"{k}={v}" for k, v in POSTHOG_ENV_DEFAULTS.items())
    if enable_minimal_mode:
        env_lines += "\nPOSTHOG_MINIMAL_MODE=true"

    return f'''
section_start "PostHog Environment"

# Create environment file
cat > /home/ph/posthog/.env << 'ENVEOF'
{env_lines}
ENVEOF

chown ph:ph /home/ph/posthog/.env

# Create simple PostHog start script (localhost access via Remote Desktop)
# Sets required env vars (DAGSTER_HOME, etc.) that bin/start computes from $0
cat > /home/ph/start-posthog.sh << 'STARTSCRIPTEOF'
#!/bin/bash
# PostHog start script for dev VM (localhost access via RDP)
# Generated by posthog-dev-pulumi startup script
#
# We set REPOSITORY_ROOT explicitly because bin/start computes it from $0,
# which doesn't work correctly when invoked through flox activate.

cd /home/ph/posthog

# Export env vars that bin/start normally sets (it can't compute them correctly
# when $0 is not the actual script path, e.g., when run through flox)
export REPOSITORY_ROOT=/home/ph/posthog
export LOCK_FILE="$REPOSITORY_ROOT/bin/start.lock"
export DAGSTER_HOME=$REPOSITORY_ROOT/.dagster_home
export DAGSTER_UI_PORT=${{DAGSTER_UI_PORT:-3030}}
export DAGSTER_UI_HOST=${{DAGSTER_UI_HOST:-localhost}}

FLOX_NO_DIRENV_SETUP=1 exec flox activate -- bin/start --custom bin/mprocs-with-logging.yaml
STARTSCRIPTEOF

chmod +x /home/ph/start-posthog.sh
chown ph:ph /home/ph/start-posthog.sh
section_end "PostHog Environment"
'''


def get_hosts_config() -> str:
    """Generate /etc/hosts configuration section."""
    return '''
section_start "Hosts Config"
# Add required entries to /etc/hosts if not present (needed for Docker service resolution)
if ! grep -q "kafka clickhouse clickhouse-coordinator objectstorage" /etc/hosts; then
    echo "127.0.0.1 kafka clickhouse clickhouse-coordinator objectstorage" >> /etc/hosts
    echo "/etc/hosts amended for PostHog services"
else
    echo "/etc/hosts already contains required entries"
fi
section_end "Hosts Config"
'''


def get_flox_activate() -> str:
    """Generate Flox environment activation section."""
    return '''
section_start "Flox Activate"
echo "This installs all dependencies and may take several minutes on first run..."

# Run flox activate in non-interactive mode to install all dependencies
# The on-activate hook in .flox/env/manifest.toml handles:
# - Python environment setup (uv sync)
# - Node.js dependencies (pnpm install)
# Note: /etc/hosts already configured above (Flox can't sudo in non-interactive mode)
# FLOX_NO_DIRENV_SETUP=1 prevents interactive direnv setup prompt
su - ph -c "cd /home/ph/posthog && FLOX_NO_DIRENV_SETUP=1 flox activate -- echo 'Flox environment activated'" || true

# Download GeoLite2 database
echo "Downloading GeoLite2 database..."
su - ph -c "cd /home/ph/posthog && FLOX_NO_DIRENV_SETUP=1 flox activate -- ./bin/download-mmdb" || true
section_end "Flox Activate"
'''


def get_docker_services() -> str:
    """Generate Docker services startup and migrations section."""
    return '''
section_start "Docker Services"
# Use || true to continue even if some containers fail (e.g., port conflicts with otel-collector)
su - ph -c "cd /home/ph/posthog && docker compose -f docker-compose.dev.yml up -d" || true

echo "Waiting for Docker services to be ready..."
sleep 30

# Ensure critical services are running (db, redis, clickhouse, kafka)
echo "Verifying critical services..."
su - ph -c "cd /home/ph/posthog && docker compose -f docker-compose.dev.yml ps db redis clickhouse kafka"

echo "Running database migrations..."
su - ph -c "cd /home/ph/posthog && FLOX_NO_DIRENV_SETUP=1 flox activate -- bin/migrate" || true

echo "Generating demo data..."
su - ph -c "cd /home/ph/posthog && FLOX_NO_DIRENV_SETUP=1 flox activate -- python manage.py generate_demo_data" || true
section_end "Docker Services"
'''


def get_start_script() -> str:
    """Generate PostHog start in screen session section."""
    return '''
section_start "Start PostHog"

# Wait a bit for migrations to settle
sleep 10

# Start PostHog in a detached screen session using the start script
# The start script:
# - Sets JS_URL/JS_POSTHOG_UI_HOST to external IP for browser access
# - Sources the Python venv (flox profile scripts only run for interactive shells)
# - Runs mprocs via flox activate
su - ph -c "screen -dmS ph /home/ph/start-posthog.sh"

echo "PostHog started in screen session 'ph' - attach with: screen -r ph"
section_end "Start PostHog"
'''
